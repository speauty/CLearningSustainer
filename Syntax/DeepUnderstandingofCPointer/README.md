### 《深度理解C指针》

指针: 存放内存地址(变量/对象(内存分配函数)/函数)的变量(阅读指针申明: 倒过来读). 

不同内存中变量的作用域和生命周期

| 类型               | 作用域                 | 生命周期             |
| ------------------ | ---------------------- | -------------------- |
| 全局内存           | 整个文件               | 应用程序的生命周期   |
| 静态内存           | 声明它的函数内部       | 应用程序的生命周期   |
| 自动内存(局部内存) | 声明它的函数内部       | 限制在函数执行时间内 |
| 动态内存           | 由引用该内存的指针决定 | 直到内存释放         |

操作符*: 声明指针(被重载过, 也用在乘法和解引指针(返回指针变量指向的值))

操作符&: 返回变量的地址

格式说明符(打印指针)

| 格式说明符 | 含义                                       |
| ---------- | ------------------------------------------ |
| %x         | 将值显示为十六进制数                       |
| %o         | 将值显示为八进制数                         |
| %p         | 将值显示为实现专用的格式, 通常是十六进制数 |

在虚拟操作系统上显示的指针地址一般不是真实的物理内存地址; 程序使用的地址是虚拟地址; 操作系统会在需要时把虚拟地址映射为物理内存地址

null指针, 指针包含了一个特殊的值, 和别的指针不一样, 没有指向任何内存区域. 两个null指针总是相等的. null指针和未初始化的指针不同. 未初始化的指针可能包含任何值, 而包含null的指针则不会引用内存中的任何地址. 任何时候都不应该对null指针进行解引, 因为它并不包含合法地址

NULL宏时强制类型转换为void指针的整数常量0

```c
#define NULL ((void *)0)
```

void指针是通用指针(将其他指针类型转换成空指针, 可以被转回原来的指针类型), 用来存放任何数据类型的引用

void指针只用做数据指针, 而不能用做函数指针

指针长度取决于使用的机器和编译器

近指针一次只能寻址64 KB的内存. 远指针最多可以寻址1MB内存, 但是比近指针慢. 巨指针是规范化过的远指针, 使用尽可能高的段

指针偏移, 给指针加上一个整数实际上加的数是这个整数和指针数据类型对应字节数的乘积. 减去整数时, 地址值会减去数据类型的长度和整数值的乘积

指针相减, 一个指针减去另一个指针会得到两个地址的差值. 可以判断数组中的元素顺序. 指针之间的差值是它们之间相差的“单位”数, 差的符号取决于操作数的顺序

指针可以用不同的间接引用层级, 比如双重指针(指向指针的指针)等

四种指针

| 指针类型             | 指针是否可修改 | 指向指针的数据是否可修改 |
| -------------------- | -------------- | ------------------------ |
| 指向非常量的指针     | 是             | 是                       |
| 指向常量的指针       | 是             | 否                       |
| 指向非常量的常量指针 | 否             | 是                       |
| 指向常量的常量指针   | 否             | 否                       |

动态分配内存, 用malloc类的函数分配内存, 用这些内存支持应用程序, 用free函数释放内存

内存泄漏, 如果不再使用已分配的内存却没有将其释放(丢失内存地址或隐式泄漏, 未使用free)

动态内存分配函数

| 函数    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| malloc  | 从堆上分配内存                                               |
| realloc | 在之前分配的内存块的基础上, 将内存重新分配为更大或更小的部分 |
| calloc  | 从堆上分配内存并清零                                         |
| free    | 将内存块返回堆                                               |

malloc函数从堆上分配一块内存, 所分配的字节数由该函数唯一的参数指定, 返回值是void指针, 如果内存不足, 就会返回NULL

realloc函数返回指向内存块的指针, 第一个参数是指向原内存块的指针, 第二个是请求的大小, 返回值是指向重新分配的内存的指针. 请求的大小可以比当前分配的字节数小或者大. 如果比当前分配的小, 那么多余的内存会还给堆, 不能保证多余的内存会被清空. 如果比当前分配的大, 那么可能的话, 就在紧挨着当前分配内存的区域分配新的内存, 否则就会在堆的其他区域分配并把旧的内存复制到新区域. 如果大小是0而指针非空，那么就释放内存

重复释放是指两次释放同一块内存

两个指针引用同一个地址称为别名

迷途指针, 如果内存已经释放，而指针还在引用原始内存. 没有指向有效对象, 有时候也称为过早释放

程序栈是支持函数执行的内存区域，通常和堆共享

程序栈存放栈帧(stack frame), 栈帧有时候也称为活跃记录(activation record)或活跃帧(activation frame)

栈溢出, 将栈帧推到程序栈上时，系统可能会耗尽内存

传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问

函数指针是持有函数地址的指针

```c
返回类型 (*函数指针变量名称) (参数...);
```

一定要确保给函数指针传递正确的参数, 否则会造成不确定的行为

尽管数组名字有时候可以当做指针来用, 但数组的名字不是指针

数组是能用索引访问的同质元素连续集合. 连续是指数组的元素在内存中是相邻的, 中间不存在空隙, 而同质是指元素都是同一类型的. 数组声明用的是方括号集合, 可以拥有多个维度

一维数组是线性结构, 用一个索引访问成员. 多维数组具有两个及两个以上维度

单独使用数组名字时会返回数组地址

如果从堆上分配内存并把地址赋给一个指针，那就肯定可以对指针使用数组下标并把这块内存当成一个数组

用malloc创建的已有数组的长度可以通过realloc函数来调整

字符串是以ASCII字符NUL结尾的字符序列. 字符串的长度是字符串中除了NUL字符之外的字符数. 为字符串分配内存时, 要记得为所有的字符再加上NUL字符分配足够的空间

为结构体分配内存时, 分配的内存大小至少是各个字段的长度和. 不过, 实际长度通常会大于这个和, 因为结构体的各字段之间可能会有填充. 某些数据类型需要对齐到特定边界就会产生填充

在为结构体分配内存时, 运行时系统不会自动为结构体内部的指针分配内存. 类似地, 当结构体消失时, 运行时系统也不会自动释放结构体内部的指针指向的内存

有界指针是指指针的使用被限制在有效的区域内

机器的字节序一般是指数据类型内部的字节顺序

小字节序是指将低位字节存储在低地址中, 而大字节序是指将高位字节存储在低地址中

句柄是系统资源的引用, 对资源的访问通过句柄实现. 不过, 句柄一般不提供对资源的直接访问, 指针则包含了资源的地址