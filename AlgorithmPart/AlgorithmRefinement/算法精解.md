## 算法精解-C语言(Kyle Loudon)描述笔记

### 基础部分

#### 数据结构简介

- 数据结构: 将数据以一种相似的方式进行组织, 这种可以简单的认为是数据结构;
- 使用数据结构的三大原因
  - 效率, 因为数据结构约束了数据的类型, 可以进行更为明确的定位(地址计算偏移等);
  - 抽象, 将对一条数据的处理提升为对一类数据的处理, 这样更具有抽象意义,和更高适用性;
  - 重用性, 因为数据结构是模块化且上下文无关的.
- 抽象数据类型(ADT): 数据结构加基本操作(插入/移除/遍历/计算元素个数等);

#### 算法简介

- 算法: 用来解决问题的步骤;

#### 指针操作

- 指针, 存储数据在内存中的地址而不是存储数据本身;
- 悬空指针, 指向无效地址的指针;
- 泛型指针, 在C语言中, 通常申明一个void指针表示;
- 函数指针, 指向可执行代码段或调用可执行代码段的信息块的指针, 而不是指向某种数据的指针.

#### 存储空间

- 可执行程序组成: 
  - 代码段包含程序运行时所执行的机器指令;
  - 静态数据区包含在程序生命周期内一直持久的数据;
  - 堆包含程序运行时动态分配的存储空间;
  - 栈包含函数调用的信息.

#### 递归

递归: 可以调用自身的函数;

递归的两个基本阶段

- 递推(向下): 每一个递归调用通过进一步调用自身来记住这次递归过程. 当其中有调用满足终止条件时, 递推结束;
- 回归(向上): 在这之前的函数调用以逆序的方式回归, 直到最初调用的函数返回为止.

基本递归: 允许一个问题以其自身越来越小的形式来定义自己;

尾递归: 一个函数中所有递归形式的调用都出现在函数的末尾, 在回归过程中不用做任何操作. 优点是当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活跃记录而不是在栈中去创建一个新的;

尾递归消除: 在函数中将最终的尾递归调用替换为等同的迭代控制结构，这不会改变函数的输出结果但能够避免一次额外的函数调用开销;

#### 算法分析

##### 最坏情况分析

最坏情况分析, 与最佳情况和平均情况相对照, 但最坏情况可以明确知道算法性能的上限. 分析一个算法的最坏情况可以保证在任何情况下此算法的表现都不会比最坏情况差，而其他情况肯定比最坏情况要好;

##### O表示法

O表示法是用来表示算法性能的最常见正式的标记法. 从形式上看, 在一定的条件因素下, O表示法指明了一个函数的上限值. 以函数所处理的数据量来表示算法的性能. 也就是说, 对于大小为n的数据, 我们用函数f(n)来表示它的算法性能.

##### 计算的复杂度

假设有一种算法, 它由k条语句组成, 每条语句都要消耗ci资源(通常是时间). 如果要计算它的整个运行时间, 无论每条语句以什么顺序执行, 我们只需要将它们的运行时间相加求和即可;

常见复杂计算发生的复杂度

- O(1), 从一个数据集中获取第一个元素;
- O(lg n), 将一个数据集分成两半, 然后将分开的每一半再分成两半, 依次类推;
- O(n), 遍历一个数据集;
- O(n lg n), 将一个数据集分成两半, 然后将分开的每一半再分成两半, 依次类推, 在此过程中同时遍历每一半数据;
- O(n^2), 遍历一个数据集中每个元素的同时遍历另一个数量级相同的数据集;
- O(2^n), 为一个数据集生成其可能的所有子集;
- O(n!), 为一个数据集生成其可能的所有排列组合;

NP完全问题, 没有已知的求解多项式时间的算法，但也无法证明此多项式不存在的问题.

### 数据结构部分

#### 链表

链表由一组元素以一种特定的顺序组合或链接在一起.

##### 单链表

单链表, 通常简称为链表, 由各个元素之间通过一个指针彼此链接起来而组成. 每个元素包含数据成员和next指针.

```
《算法（第4版）》
《TCP/IP详解》
《深入理解计算机系统》
《算法导论》
```





